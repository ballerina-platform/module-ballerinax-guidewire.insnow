// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

# This OpenAPI specification outlines the interface for the Guidewire InsuranceNow Cloud API version 5.0.0, providing a comprehensive description of available endpoints, operations, parameters, request bodies, and response structures for integrating with the cloud-based insurance platform, InsuranceNow. Designed to streamline operations for insurance companies, InsuranceNow offers functionalities including policy management, claims management, and customer engagement. The API enables developers to access and manipulate insurance data, facilitating automation, custom integrations, and workflow enhancements. Key features include policy management, claims processing, and customer management.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl) returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Returns a list of supported countries.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get addresses/countries(map<string|string[]> headers = {}, *GetSupportedCountriesQueries queries) returns ListCountry|error {
        string resourcePath = string `/addresses/countries`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns the AddressCountryTemplate bean for the given IsoCd (e.g. US).
    #
    # + isoCd - ISO Country code
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get addresses/countries/[string isoCd](map<string|string[]> headers = {}) returns AddressCountryTemplate|error {
        string resourcePath = string `/addresses/countries/${getEncodedUri(isoCd)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Fills an address from a Google Places search. Using the placeId from a Google Places search, an address will be returned that has all of the address components filled. If the placeId is not known, Google Places will be called to search and fill the address components.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get addresses/googlePlacesFill(map<string|string[]> headers = {}, *FillAddressFromGooglePlacesQueries queries) returns Address|error {
        string resourcePath = string `/addresses/googlePlacesFill`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Indicates whether a given address is already verified.
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post addresses/isVerifiedRequest(Address payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/addresses/isVerifiedRequest`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Normalizes, verifies, and provides a more complete address. The verified address may include additional address properties. The response either returns one or more addresses that match the given address, or it will return an error if the address cannot be verified. If more than one address is returned, select an address and then resubmit the API request to perform address verification on the selected address.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function post addresses/verificationRequest(ListAddress payload, map<string|string[]> headers = {}, *VerifyAddressQueries queries) returns error? {
        string resourcePath = string `/addresses/verificationRequest`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns a list of quotes or applications.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get applications(map<string|string[]> headers = {}, *GetQuotesQueries queries) returns ListApplication|error {
        string resourcePath = string `/applications`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Starts a new QuickQuote or Quote. To create a QuickQuote, basicPolicy productVersionIdRef (e.g. Homeowners-1.00.00), providerRef (e.g. 19), and effectiveDt strings are required. To create a Quote, basicPolicy productVersionIdRef, providerRef, and effectiveDt strings, plus one piece of insured information to create a customer, are required.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function post applications(Quote payload, map<string|string[]> headers = {}, *CreateQuoteQueries queries) returns error? {
        string resourcePath = string `/applications`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete the quote or application.
    #
    # + systemId - System identifier of the quote or application
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete applications/[string systemId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Converts a quote to an application.
    #
    # + systemId - System identifier of the quote
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post applications/[string systemId]/bindRequest(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/bindRequest`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Converts a QuickQuote to a Quote.
    #
    # + systemId - System identifier of the quote
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post applications/[string systemId]/convertToQuoteRequest(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/convertToQuoteRequest`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns a list of documents for a quote or application.
    #
    # + systemId - System identifier of the application
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get applications/[string systemId]/documents(map<string|string[]> headers = {}) returns ListDocument|error {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/documents`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Adds an attachment to a quote or application.
    #
    # + systemId - System identifier of the application
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post applications/[string systemId]/documents(Attachment payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/documents`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Deletes an attachment associated with a quote or application. Requires the attachment ref number (e.g. "Attachment-26808155-290885540").
    #
    # + systemId - System identifier of the application
    # + documentId - The identifier of the document
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete applications/[string systemId]/documents/[string documentId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/documents/${getEncodedUri(documentId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Downloads a document for a quote or application. Requires the attachment ref number (e.g. "Attachment-26808155-290885540").
    #
    # + systemId - System identifier of the application
    # + documentId - The identifier of the document
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get applications/[string systemId]/documents/[string documentId]/content(map<string|string[]> headers = {}) returns byte[]|error {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/documents/${getEncodedUri(documentId)}/content`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns a list of the drivers or non-drivers of a quote or application.
    #
    # + systemId - System identifier of the quote or application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get applications/[string systemId]/drivers(map<string|string[]> headers = {}, *GetDriversQueries queries) returns ListDriver|error {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/drivers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a new driver or non-driver. You must include a partyTypeCd (DriverParty or NonDriverParty). Other details may be required depending on the insurance product being quoted.
    #
    # + systemId - System identifier of the quote or application
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post applications/[string systemId]/drivers(Driver payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/drivers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns details about a driver or non-driver.
    #
    # + systemId - System identifier of the quote or application
    # + driverNumber - Driver/non-driver number
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get applications/[string systemId]/drivers/[int:Signed32 driverNumber](map<string|string[]> headers = {}) returns Driver|error {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/drivers/${getEncodedUri(driverNumber)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Replaces the details about a driver or non-driver.
    #
    # + systemId - System identifier of the quote or application
    # + driverNumber - Driver/non-driver number
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function put applications/[string systemId]/drivers/[int:Signed32 driverNumber](Driver payload, map<string|string[]> headers = {}) returns Driver|error {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/drivers/${getEncodedUri(driverNumber)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Deletes a driver/non-driver.
    #
    # + systemId - System identifier of the quote or application
    # + driverNumber - Driver/non-driver number
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete applications/[string systemId]/drivers/[int:Signed32 driverNumber](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/drivers/${getEncodedUri(driverNumber)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Makes changes to details about a driver/non-driver.
    #
    # + systemId - System identifier of the quote or application
    # + driverNumber - Driver/non-driver number
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function patch applications/[string systemId]/drivers/[int:Signed32 driverNumber](Driver payload, map<string|string[]> headers = {}) returns Driver|error {
        string resourcePath = string `/applications/${getEncodedUri(systemId)}/drivers/${getEncodedUri(driverNumber)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Returns the list of documents attached to a claim.
    #
    # + systemId - System identifier of the claim
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get claims/[string systemId]/documents(map<string|string[]> headers = {}) returns ListDocument|error {
        string resourcePath = string `/claims/${getEncodedUri(systemId)}/documents`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Adds an attachment to a claim.
    #
    # + systemId - System identifier of the claim
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post claims/[string systemId]/documents(DocumentDetail payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/claims/${getEncodedUri(systemId)}/documents`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns a list of notes for a claim.
    #
    # + systemId - System identifier of the claim
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get claims/[string systemId]/notes(map<string|string[]> headers = {}) returns ListNote|error {
        string resourcePath = string `/claims/${getEncodedUri(systemId)}/notes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Adds a note to a claim.
    #
    # + systemId - System identifier of the claim
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post claims/[string systemId]/notes(NoteDetail payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/claims/${getEncodedUri(systemId)}/notes`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns a list of policies.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get policies(map<string|string[]> headers = {}, *GetPoliciesQueries queries) returns ListPolicy|error {
        string resourcePath = string `/policies`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns the full details of a policy.
    #
    # + systemId - System identifier of the policy
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get policies/[string systemId](map<string|string[]> headers = {}, *GetPolicyQueries queries) returns PolicyDetails|error {
        string resourcePath = string `/policies/${getEncodedUri(systemId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates the preferred delivery method and insured email address of the policy. Requires the systemId.
    #
    # + systemId - System identifier of the policy
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function patch policies/[string systemId](PolicyDetails payload, map<string|string[]> headers = {}) returns PolicyDetails|error {
        string resourcePath = string `/policies/${getEncodedUri(systemId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }
}
